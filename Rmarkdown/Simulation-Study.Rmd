---
title: "Simulation Study"
output:
  html_document: default
  word_document: default
  pdf_document: default
date: "`r Sys.Date()`"
---

### Required Libraries

```{r}
library(tidyverse)
library(patchwork)
library(latex2exp)
library(ggplot2)
```

### Load Data, MCMC Output and Preprocess

```{r}
out <- readRDS("0720_dpglm_simulation_all.rds")
num_datasets <- length(out)
num_settings <- length(out[[1]])

# remove out[[]][[]] if NULL
null_idx <- numeric(0)
for (dat_idx in 1:num_datasets) {
  for (setting in 1:num_settings) {
    if (is.null(out[[dat_idx]][[setting]])) {
      null_idx <- c(null_idx, dat_idx)
    }
  }
}
out <- out[-unique(null_idx)]

mcmc_out <- lapply(out, function(sublist) {
  lapply(sublist, function(inner_sublist)
    inner_sublist$mcmc)
})

dat_out <- lapply(out, function(sublist) {
  lapply(sublist, function(inner_sublist)
    inner_sublist$data)
})

beta_samples <- lapply(mcmc_out, function(sublist) {
  lapply(sublist, function(inner_sublist)
    inner_sublist$beta)
})

theta_samples <- lapply(mcmc_out, function(sublist) {
  lapply(sublist, function(inner_sublist)
    inner_sublist$theta)
})

z_samples <- lapply(mcmc_out, function(sublist) {
  lapply(sublist, function(inner_sublist)
    inner_sublist$z)
})

crm_samples <- lapply(mcmc_out, function(sublist) {
  lapply(sublist, function(inner_sublist)
    inner_sublist$crm)
})
```

## Setting I: Null Case

### Simulation Ground Truths for $f_0$

Based on the KDE of the true data, we estimate the ground truth for $f_0(y)$. Here, $\mu_0$ is the ground truth for $E_{f_0}(y)$. $y$ grids in the range $[0, 1]$. $K(y \mid z) = unif(y; \ z - c_0, z + c_0)$ with $c_0 = 0.025$, and $p(z \mid x, \theta_{x}, \tilde \mu) = p_x(z) \propto \exp(\theta_{x} z) \tilde \mu(z)$, with $\theta_x = 0$ for the null case.

```{r}
hustadTD <- readRDS("/Users/entejar/Library/CloudStorage/Box-Box/DP-GLM/Data/hustadTD.rds")
hustadTDMW <- filter(hustadTD %>% as.data.frame(),
                     intelligibility_type == 'multiword') %>% arrange(mean_intelligibility)

# KDE
dens  <- density(
  hustadTDMW$mean_intelligibility,
  kernel = 'gaussian',
  bw = 'nrd0',
  adjust = 1,
  n = 1000,
  cut = 3,
  ext = 4
)
dat   <- data.frame(y = dens$x, f0 = dens$y)
indx_0_1  <- dat$y >= 0 & dat$y <= 1
true_spt   <- dat$y[indx_0_1]
true_f0    <- dat$f0[indx_0_1]
true_f0 <- true_f0 / sum(true_f0)
mu0 <- sum(true_spt * true_f0)   # ground truth for mu0
c0 <- 0.025
```

### Comparing RMSEs in estimating $f_0(y)$ and $F_0(y)$, for a given $y$

The kernel $K(y \mid z) = unif(y; \ z - c_0, z + c_0), y \in [0, 1]$.

For a given data replicate and MCMC iteration, the density $f(y \mid x) = \int_z K(y \mid z, x) p(z \mid x, \theta_{x}, \tilde \mu) dz = \sum_{\ell} \frac{1}{2c_0} 1_{\{z_\ell - c_0 , z_\ell + c_0\}}(y) \frac{\exp(\theta_x z_\ell) J_\ell}{\sum_{\ell'}\exp(\theta_x z_{\ell'}) J_{\ell'}}$. From here, we get $f_0(y)$ by replacing $\theta_x = 0$. Let's call $\frac{\exp(\theta_x z_\ell) J_\ell}{\sum_{\ell'}\exp(\theta_x z_{\ell'}) J_{\ell'}} = \pi_{\ell}(\theta_x)$. So, $f(y \mid x) = \sum_{\ell} \pi_{\ell}(\theta_x) \frac{1}{2c_0} 1_{\{z_\ell - c_0 , z_\ell + c_0\}}(y)$.

Similarly, the CDF $F(y \mid x) = \int_{0}^{y} f(y' \mid x) dy' = \sum_{\ell} \pi_\ell(\theta_x) \left[\left(\frac{y - z_\ell + c_0}{2c_0}\right) 1_{\{z_\ell - c_0,  z_\ell + c_0\}}(y) + \left(\frac{2c_0}{2c_0}\right) 1_{\{z_\ell + c_0 < y\}}(y) + 0 \cdot 1_{y < z_\ell - c_0}(y) \right]$. From here, we get $F_0(y)$ by replacing $\theta_x = 0$.

```{r}
yGrid <- true_spt 
theta <- 0
true_pro <- exp(theta * true_spt) * true_f0
true_pk  <- true_pro / sum(true_pro)
F0_true <- f0_true <- numeric(length(yGrid))
for (i in 1:length(yGrid)) {
  indx <- which(true_spt >= (yGrid[i] - c0) & true_spt <= (yGrid[i] + c0))
  f0_true[i] <- sum(true_pk[indx]) * (1 / (2 * c0))
  indx2 <- which(true_spt <= yGrid[i] - c0)
  F0_true[i] <- sum(true_pk[indx2]) + 
    sum(true_pk[indx] * (yGrid[i] - true_spt[indx] + c0)/ (2 * c0))
}

theta_solver <- function(z.tld, J.tld, mu, thtst){
  out <- gldrm:::getTheta(spt = z.tld, f0 = J.tld, mu = mu, sampprobs = NULL,
                          ySptIndex = NULL, thetaStart = thtst)
  tht <- out$theta
  bpr2 <- out$bPrime2
  btht <- apply(exp(outer(tht, z.tld, "*")), 1, function(row) log(sum(row * J.tld)))
  return(list(bpr2 = bpr2, tht = tht, btht = btht))
}


plot_grid <- seq(1, length(true_spt), 1)
yGrid <- true_spt[plot_grid]

itr_indx <- seq(1, 1000, 10)

f_est_fn <- function(setting) {
  F0_est_list <- f0_est_list <- list()
  for (dat_indx in 1:length(dat_out)) {
    F0_est <- f0_est <- matrix(NA, nrow = length(yGrid), ncol = length(itr_indx))
    for (j in 1:length(itr_indx)) {
      itr <- itr_indx[j]
      spt <- crm_samples[[dat_indx]][[setting]][[itr]]$z.tld
      f0 <- crm_samples[[dat_indx]][[setting]][[itr]]$J.tld
      tht <- theta_solver(spt, f0, mu0, NULL)$tht
      f0 <- exp(tht * spt) * f0 / sum(exp(tht * spt) * f0)
      theta <- 0
      for (i in 1:length(yGrid)) {
        pro <- exp(theta * spt) * f0  # which is same as f0 for the null case
        pk  <- pro / sum(pro)
        indx <- which(spt >= (yGrid[i] - c0) & spt <= (yGrid[i] + c0))
        f0_est[i, j] <- sum(pk[indx]) * (1 / (2 * c0))
        indx2 <- which(spt <= yGrid[i] - c0)
        F0_est[i, j] <- sum(pk[indx2]) + 
          sum(pk[indx] * (yGrid[i] - spt[indx] + c0)/ (2 * c0))
      }                                                              
      
    }
    f0_est_list[[dat_indx]] <- f0_est
    F0_est_list[[dat_indx]] <- F0_est
  }
  
  return(list(f0 = f0_est_list,
         F0 = F0_est_list))
}

out1 <- f_est_fn(1)
out2 <- f_est_fn(2)
out3 <- f_est_fn(3)
```

#### Some Quantitative Summary

```{r}
F0_est1 <- reduce(lapply(out1$F0, rowMeans), `+`) / length(out1$F0) %>% as.numeric() 
F0_est2 <- reduce(lapply(out2$F0, rowMeans), `+`) / length(out2$F0) %>% as.numeric()
F0_est3 <- reduce(lapply(out3$F0, rowMeans), `+`) / length(out3$F0) %>% as.numeric()
F0_all <- data.frame(F0_true[plot_grid], F0_est1, F0_est2, F0_est3)
colnames(F0_all) <- c("F0_true", "F0_est1", "F0_est2", "F0_est3")

F0_all %>% head() %>% round(., 5)

F0_all %>% tail() %>% round(., 3)
```

#### RMSE: (mean / median / max over y) for a data replicate

First plot: for $F_0$, Second plot: for $f_0$.

$M$ in R($M$)SE denotes `mean`, `median` or `max`.

For a given data replicate, eg. R(`mean`)SE = $\sqrt{\frac{1}{I} \sum_{i=1}^{I} (\hat F_0(y_i) - F_0^{true}(y_i))^2}$, where $I$ is the number of $y$ grids and $\hat F_0(y_i)$ is the posterior mean est of $F_0^{true}(y_i)$ for the $i$-th grid point. So, we have `num_datasets` RMSE values for $F_0$ and $f_0$. We plot the boxplots of these RMSE values for different sample sizes, and also for different choices of $M$.

```{r}
rmse <- function(f0, F0, f0_true, F0_true, fn) {
  mseF0 <- lapply(1:length(F0), function(i)
    fn((rowMeans(F0[[i]]) - F0_true)^2) %>% sqrt())
  msef0 <- lapply(1:length(f0), function(i)
    fn((rowMeans(f0[[i]]) - f0_true)^2 %>% sqrt()))
  return(list(mseF0 = mseF0, msef0 = msef0))
}

plot_rmse <- function(fn) {
  rmse_1 <- rmse(out1$f0, out1$F0, f0_true, F0_true, fn)
  rmse_2 <- rmse(out2$f0, out2$F0, f0_true, F0_true, fn)
  rmse_3 <- rmse(out3$f0, out3$F0, f0_true, F0_true, fn)
  rmseF0_all <- data.frame(
    rmse = c(rmse_1$mseF0 %>% unlist(), 
             rmse_2$mseF0 %>% unlist(), 
             rmse_3$mseF0 %>% unlist()),
    n = factor(rep(c("25", "100", "250"), 
                       each = length(rmse_1$mseF0)))
  )
  
  rmseF0_all$n <- factor(rmseF0_all$n, levels = c("25", "100", "250"))
  
  rmsef0_all <- data.frame(
    rmse = c(rmse_1$msef0 %>% unlist(), 
             rmse_2$msef0 %>% unlist(), 
             rmse_3$msef0 %>% unlist()),
    n = factor(rep(c("25", "100", "250"), 
                       each = length(rmse_1$msef0)))
  )
  
  rmsef0_all$n <- factor(rmsef0_all$n, levels = c("25", "100", "250"))
  
  FyLab <- paste("R (", deparse(substitute(fn)), "over y) SE in estimating $F_0(y)$")
  fyLab <- paste("R (", deparse(substitute(fn)), "over y) SE in estimating $f_0(y)$")
  
  pltF0 <- ggplot() +
    geom_boxplot(data = rmseF0_all, aes(x = n, y = rmse), outliers = F) +
    theme_bw() +
    labs(x = "sample size", y = TeX(FyLab)) +
    theme(legend.position = "top") 
  
  pltf0 <- ggplot() +
    geom_boxplot(data = rmsef0_all, aes(x = n, y = rmse), outliers = F) +
    theme_bw() +
    labs(x = "sample size", y = TeX(fyLab)) +
    theme(legend.position = "top")
  
  return(list(F0 = pltF0, f0 = pltf0))
}

plot_rmse(mean)$F0 + plot_rmse(median)$F0 + plot_rmse(max)$F0

plot_rmse(mean)$f0 + plot_rmse(median)$f0 + plot_rmse(max)$f0
```

#### Comparing SAD in estimating $f_0(y)$ and $F_0(y)$, for a given $y$

Left plot: for $F_0$, Right plot: for $f_0$).

For a given $y$, `SAD` = (scaled) absolute deviation = $\frac{|\hat F_0(y) - F_0^{true}(y)|}{F_0^{true}(y)}$ or $\frac{|\hat f_0(y) - f_0^{true}(y)|}{f_0^{true}(y)}$, where $\hat F_0(y)$ and $\hat f_0(y)$ are the posterior mean estimates of $F_0(y)$ and $f_0(y)$, respectively. So, for a given $y$, we have `num_datasets` SAD values for $F_0(y)$ and $f_0(y)$. We plot the boxplots of these SAD values for different sample sizes and for different $y$ grids.

```{r}
sad <- function(f0, F0, f0_true, F0_true) {
  sadF0 <- lapply(1:length(F0), function(i)
    abs(rowMeans(F0[[i]]) - F0_true) / F0_true)
  sadf0 <- lapply(1:length(f0), function(i)
    abs(rowMeans(f0[[i]]) - f0_true) / f0_true)
  return(list(sadF0 = sadF0, sadf0 = sadf0))
}

plot_sad <- function(plot_grid) {
  sad_1 <- sad(out1$f0, out1$F0, f0_true, F0_true)
  sad_2 <- sad(out2$f0, out2$F0, f0_true, F0_true)
  sad_3 <- sad(out3$f0, out3$F0, f0_true, F0_true)
  
  sadF0_all <- data.frame(
    sad = c(sad_1$sadF0 %>% unlist(), 
            sad_2$sadF0 %>% unlist(), 
            sad_3$sadF0 %>% unlist()),
    y = rep(yGrid, 3 * length(sad_1$sadF0)),
    n = factor(rep(c("25", "100", "250"), 
                       each = length(sad_1$sadF0)))
  )
  sadF0_all$n <- factor(sadF0_all$n, levels = c("25", "100", "250"))
  
  sadf0_all <- data.frame(
    sad = c(sad_1$sadf0 %>% unlist(), 
            sad_2$sadf0 %>% unlist(), 
            sad_3$sadf0 %>% unlist()),
    y = rep(yGrid, 3 * length(sad_1$sadf0)),
    n = factor(rep(c("25", "100", "250"), 
                       each = length(sad_1$sadf0)))
  )
  sadf0_all$n <- factor(sadf0_all$n, levels = c("25", "100", "250"))
  
  pltF0 <- ggplot() +
    geom_boxplot(data = sadF0_all %>% filter(y %in% yGrid[plot_grid]), 
                 aes(x = factor(round(y, 3)), y = sad, col = n), outliers = F) +
    theme_bw() +
    labs(x = "y", y = TeX("SAD in estimating $F_0(y)$")) +
    theme(legend.position = "top") 
  
  pltf0 <- ggplot() +
    geom_boxplot(data = sadf0_all %>% filter(y %in% yGrid[plot_grid]), 
                 aes(x = factor(round(y, 3)), y = sad, col = n), outliers = F) +
    theme_bw() +
    labs(x = "y", y = TeX("SAD in estimating $f_0(y)$")) +
    theme(legend.position = "top")
  
  return(list(F0 = pltF0, f0 = pltf0))
}

plot_sad(c(200, 400, 600, 800))$F0 + plot_sad(c(200, 400, 600, 800))$f0
```

### Comparing coverages in estimating $f_0(y)$ and $F_0(y)$, for a given $y$

```{r}
coverage_fn <- function(f0, F0, f0_true, F0_true){
  F0_est_list <- F0
  f0_est_list <- f0
  
  F0_est_q <- lapply(F0_est_list, 
                     function(x) apply(x, 1, quantile, prob = c(0.025, 0.975)))
  coverageF0 <- lapply(F0_est_q, function(x) {
    (x[2, ] >= F0_true & x[1, ] <= F0_true)
  })

  f0_est_q <- lapply(f0_est_list, 
                     function(x) apply(x, 1, quantile, prob = c(0.025, 0.975)))
  coveragef0 <- lapply(f0_est_q, function(x) {
    (x[2, ] >= f0_true & x[1, ] <= f0_true)
  })


  return(list(coveragef0 = coveragef0,
              CIf0 = f0_est_q,
              coverageF0 = coverageF0,
              CIF0 = F0_est_q))
}
outcov1 <- coverage_fn(out1$f0, out1$F0, f0_true, F0_true)
outcov2 <- coverage_fn(out2$f0, out2$F0, f0_true, F0_true)
outcov3 <- coverage_fn(out3$f0, out3$F0, f0_true, F0_true)

coverageF0_all <- data.frame(
  coverage = c(reduce(outcov1$coverageF0, `+`) / length(outcov1$coverageF0),
               reduce(outcov2$coverageF0, `+`) / length(outcov2$coverageF0),
               reduce(outcov3$coverageF0, `+`) / length(outcov3$coverageF0)),
  y = rep(yGrid, 3),
  group = factor(rep(c("n = 25", "n = 100", "n = 250"), each = length(yGrid)))
)
coverageF0_all$group <- factor(coverageF0_all$group, levels = c("n = 25", "n = 100", "n = 250"))

plot_grid <- c(100, 200, 400, 600, 800)
coverageF0_all <- coverageF0_all %>% filter(y %in% yGrid[plot_grid])
pal <- ggthemes::colorblind_pal()(8)

p1 <- ggplot() +
  geom_point(data = coverageF0_all, aes(x = factor(round(y, 3)), y = coverage, col = group),
             position = position_dodge(width = 0.2)) +
  theme_classic() +
  labs(x = "y", y = TeX("Coverage of 95% CI for $F_0(y)$")) +
  theme(legend.position = "top") +
  scale_color_manual(
    name = "sample size (n)",
    labels = c("n = 25" = "25", "n = 100" = "100", "n = 250" = "250"),
    values = c("n = 25" = pal[3], "n = 100" = pal[8], "n = 250" = pal[6])
  ) +
  geom_hline(yintercept = 0.95, linetype = "dashed", col = "black") +
  annotate(
    "text",
    x = 4,
    y = 0.952,
    label = "95% coverage line",
    col = "red"
  )

coveragef0_all <- data.frame(
  coverage = c(reduce(outcov1$coveragef0, `+`) / length(outcov1$coveragef0),
               reduce(outcov2$coveragef0, `+`) / length(outcov2$coveragef0),
               reduce(outcov3$coveragef0, `+`) / length(outcov3$coveragef0)),
  y = rep(yGrid, 3),
  group = factor(rep(c("n = 25", "n = 100", "n = 250"), each = length(yGrid)))
)
coveragef0_all$group <- factor(coveragef0_all$group, levels = c("n = 25", "n = 100", "n = 250"))

plot_grid <- c(100, 200, 400, 600, 800)
coveragef0_all <- coveragef0_all %>% filter(y %in% yGrid[plot_grid])
pal <- ggthemes::colorblind_pal()(8)

p2 <- ggplot() +
  geom_point(data = coveragef0_all, aes(x = factor(round(y, 3)), y = coverage, col = group),
             position = position_dodge(width = 0.2)) +
  theme_classic() +
  labs(x = "y", y = TeX("Coverage of 95% CI for $f_0(y)$")) +
  theme(legend.position = "top") +
  scale_color_manual(
    name = "sample size (n)",
    labels = c("n = 25" = "25", "n = 100" = "100", "n = 250" = "250"),
    values = c("n = 25" = pal[3], "n = 100" = pal[8], "n = 250" = pal[6])
  ) +
  geom_hline(yintercept = 0.95, linetype = "dashed", col = "black") +
  annotate(
    "text",
    x = 4,
    y = 0.952,
    label = "95% coverage line",
    col = "red"
  )

p1 + p2

```

#### Comparing UI (scaled) length in estimating $f_0(y)$ and $F_0(y)$, for a given $y$

`U`ncertainty `I`nterval (scaled) length = $\frac{|\hat F_0^{0.975}(y) - \hat F_0^{0.025}(y)|}{F_0^{true}(y)}$ or $\frac{|\hat f_0^{0.975}(y) - \hat f_0^{0.025}(y)|}{f_0^{true}(y)}$, where $\hat F_0^{0.975}(y)$ and $\hat f_0^{0.975}(y)$ are the posterior 97.5th percentile estimates of $F_0(y)$ and $f_0(y)$, respectively, and $\hat F_0^{0.025}(y)$ and $\hat f_0^{0.025}(y)$ are the posterior 2.5th percentile estimates of $F_0(y)$ and $f_0(y)$, respectively. So, for a given $y$, we have `num_datasets` UI (scaled) length values for $F_0(y)$ and $f_0(y)$. We plot the boxplots of these UI (scaled) length values for different sample sizes and for different $y$ grids.

```{r}
UIlen_fn <- function(f0, F0, f0_true, F0_true){
  F0_est_list <- F0
  f0_est_list <- f0
  
  F0_est_q <- lapply(F0_est_list, 
                     function(x) apply(x, 1, quantile, prob = c(0.025, 0.975)))
  UIlenF0 <- lapply(F0_est_q, function(x) {
    x[2, ] - x[1, ] / F0_true
  })

  f0_est_q <- lapply(f0_est_list, 
                     function(x) apply(x, 1, quantile, prob = c(0.025, 0.975)))
  UIlenf0 <- lapply(f0_est_q, function(x) {
    x[2, ] - x[1, ] / f0_true
  })
  
  return(list(UIlenF0 = UIlenF0,
              UIlenf0 = UIlenf0))
}

outUIlen1 <- UIlen_fn(out1$f0, out1$F0, f0_true, F0_true)
outUIlen2 <- UIlen_fn(out2$f0, out2$F0, f0_true, F0_true)
outUIlen3 <- UIlen_fn(out3$f0, out3$F0, f0_true, F0_true)

UIlenF0_all <- data.frame(
  UIlen = c(reduce(outUIlen1$UIlenF0, `+`) / length(outUIlen1$UIlenF0),
            reduce(outUIlen2$UIlenF0, `+`) / length(outUIlen2$UIlenF0),
            reduce(outUIlen3$UIlenF0, `+`) / length(outUIlen3$UIlenF0)),
  y = rep(yGrid, 3),
  group = factor(rep(c("n = 25", "n = 100", "n = 250"), each = length(yGrid)))
)

UIlenF0_all$group <- factor(UIlenF0_all$group, levels = c("n = 25", "n = 100", "n = 250"))
plot_grid <- c(100, 200, 400, 600, 800)
UIlenF0_all <- UIlenF0_all %>% filter(y %in% yGrid[plot_grid])

UIlenf0_all <- data.frame(
  UIlen = c(reduce(outUIlen1$UIlenf0, `+`) / length(outUIlen1$UIlenf0),
            reduce(outUIlen2$UIlenf0, `+`) / length(outUIlen2$UIlenf0),
            reduce(outUIlen3$UIlenf0, `+`) / length(outUIlen3$UIlenf0)),
  y = rep(yGrid, 3),
  group = factor(rep(c("n = 25", "n = 100", "n = 250"), each = length(yGrid)))
)

UIlenf0_all$group <- factor(UIlenf0_all$group, levels = c("n = 25", "n = 100", "n = 250"))
plot_grid <- c(100, 200, 400, 600, 800)
UIlenf0_all <- UIlenf0_all %>% filter(y %in% yGrid[plot_grid])

pal <- ggthemes::colorblind_pal()(8)

p1 <- ggplot() +
  geom_point(data = UIlenF0_all, aes(x = factor(round(y, 3)), y = UIlen, col = group),
             position = position_dodge(width = 0.2)) +
  theme_classic() +
  labs(x = "y", y = TeX("UI (scaled) length of 95% CI for $F_0(y)$")) +
  theme(legend.position = "top") +
  scale_color_manual(
    name = "sample size (n)",
    labels = c("n = 25" = "25", "n = 100" = "100", "n = 250" = "250"),
    values = c("n = 25" = pal[3], "n = 100" = pal[8], "n = 250" = pal[6])
  )

p2 <- ggplot() +
  geom_point(data = UIlenf0_all, aes(x = factor(round(y, 3)), y = UIlen, col = group),
             position = position_dodge(width = 0.2)) +
  theme_classic() +
  labs(x = "y", y = TeX("UI (scaled) length of 95% CI for $f_0(y)$")) +
  theme(legend.position = "top") +
  scale_color_manual(
    name = "sample size (n)",
    labels = c("n = 25" = "25", "n = 100" = "100", "n = 250" = "250"),
    values = c("n = 25" = pal[3], "n = 100" = pal[8], "n = 250" = pal[6])
  )

p1 + p2

```

### Comparing $\beta_j$ estimates

```{r}
beta_est <- lapply(beta_samples, function(sublist) {
  lapply(sublist, function(inner_sublist)
    colMeans(inner_sublist))
})
```

#### For setting I (null case)

We plot the boxplots of the posterior estimates of $\beta_j$ for $j = 0, 1, 2$ for different sample sizes. The black dashed line represents the $0$-line.

```{r}
beta_est_setIDF <- data.frame(beta = lapply(beta_est, function(sublist)
  sublist[1:3]) %>% unlist(),
  group = factor(rep(1:3, 3 * length(beta_est)),
                 labels = c("beta0", "beta1", "beta2")),
  n = factor(rep(rep(c("25", "100", "250"), each = 3), length(beta_est)))
)

beta_est_setIDF$n <- factor(beta_est_setIDF$n, levels = c("25", "100", "250"))

p1 <- ggplot() +
  geom_boxplot(data = beta_est_setIDF, aes(x = group, y = beta, col = n), outliers = F) +
  theme_bw() +
  labs(x = "", y = "Estimates") +
  theme(legend.position = "top") +
  geom_hline(yintercept = 0, linetype = "dashed", col = "black") 
  
p1
```

#### For setting II (point masses)

We plot the boxplots of the posterior estimates of $\beta_j$ for $j = 0, 1, 2$ for different sample sizes. The black dashed line represents the $0$-line.

```{r}
beta_est_setIIDF <- data.frame(beta = lapply(beta_est, function(sublist)
  sublist[4:6]) %>% unlist(),
  group = factor(rep(1:3, 3 * length(beta_est)),
                 labels = c("beta0", "beta1", "beta2")),
  n = factor(rep(rep(c("25", "100", "250"), each = 3), length(beta_est))
))

beta_est_setIIDF$n <- factor(beta_est_setIIDF$n, levels = c("25", "100", "250"))

p2 <- ggplot() +
  geom_boxplot(data = beta_est_setIIDF, aes(x = group, y = beta, col = n), outliers = F) +
  theme_bw() +
  labs(x = "", y = "Estimates") +
  theme(legend.position = "top") +
  geom_hline(yintercept = 0, linetype = "dashed", col = "black")

p2
```

#### For setting III (regression)

The true values of $\beta_j$ are 0.1, 0.25 and 0.75 for $j = 0, 1, 2$, respectively. We plot the density of posterior samples of $\beta_j$ for $j = 0, 1, 2$, for different sample sizes. The black dashed line represents the true value of $\beta_j$.

```{r}
beta_est_setIIIDF <- data.frame(beta =  lapply(beta_samples, function(sublist) {
  rbind(sublist[7], sublist[8], sublist[9]) 
  }) %>% unlist(),
  group = rep(rep(paste0("beta", 1:3), each = 1000), length(beta_samples) *  3),
  n = rep(rep(c("25", "100", "250"), each = 3000), length(beta_samples)),
  true = rep(rep(c(0.1, 0.25, 0.75), each = 1000), length(beta_samples) *  3))

beta_est_setIIIDF$n <- factor(beta_est_setIIIDF$n, levels = c("25", "100", "250"))

p3 <- ggplot(data = beta_est_setIIIDF) +
  geom_density(aes(x = beta, col = n)) +
  theme_bw() +
  facet_wrap(. ~ group, scales = "free") +
  labs(x = "", y = "Density") +
  theme(legend.position = "top") +
  geom_vline(aes(xintercept = true), linetype = "dashed") 

p3

```
